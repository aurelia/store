// Generated by dts-bundle-generator v5.9.0

import { Container } from 'aurelia-dependency-injection';
import { Logger } from 'aurelia-logging';
import { Observable } from 'rxjs';

export interface StateHistory<T> {
	past: T[];
	present: T;
	future: T[];
}
export interface HistoryOptions {
	undoable: boolean;
	limit?: number;
}
export declare function jump<T>(state: T, n: number): T | StateHistory<any>;
export declare function nextStateHistory<T>(presentStateHistory: StateHistory<T>, nextPresent: T): StateHistory<T>;
export declare function applyLimits<T>(state: T, limit: number): T;
export declare function isStateHistory(history: any): history is StateHistory<any>;
export declare const DEFAULT_LOCAL_STORAGE_KEY = "aurelia-store-state";
export interface CallingAction {
	name: string;
	params?: any[];
	pipedActions?: {
		name: string;
		params?: any[];
	}[];
}
export declare type Middleware<T, S = any> = (state: T, originalState: T | undefined, settings: S, action?: CallingAction) => T | Promise<T | undefined | false> | void | false;
export declare enum MiddlewarePlacement {
	Before = "before",
	After = "after"
}
export declare function logMiddleware(state: unknown, _: unknown, settings?: {
	logType: "debug" | "error" | "info" | "log" | "trace" | "warn";
}): void;
export declare function localStorageMiddleware(state: unknown, _: unknown, settings?: {
	key: string;
}): void;
export declare function rehydrateFromLocalStorage<T>(state: T, key?: string): any;
export declare enum LogLevel {
	trace = "trace",
	debug = "debug",
	info = "info",
	log = "log",
	warn = "warn",
	error = "error"
}
export declare class LoggerIndexed extends Logger {
	[key: string]: any;
}
export interface LogDefinitions {
	performanceLog?: LogLevel;
	dispatchedActions?: LogLevel;
	devToolsStatus?: LogLevel;
}
export declare function getLogType(options: Partial<StoreOptions>, definition: keyof LogDefinitions, defaultLevel: LogLevel): LogLevel;
export interface Action<T = any> {
	type: T;
	params?: any[];
}
export interface ActionCreator<T> {
	(...args: any[]): T;
}
export interface DevToolsOptions {
	/**
	 * If disable is true, devtools monitoring
	 * will be disabled in the browser (disallowing a user to see your state using Redux Dev Tools)
	 */
	disable?: boolean;
	/**
	 * the instance name to be showed on the monitor page. Default value is `document.title`.
	 * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.
	 */
	name?: string;
	/**
	 * action creators functions to be available in the Dispatcher.
	 */
	actionCreators?: ActionCreator<any>[] | {
		[key: string]: ActionCreator<any>;
	};
	/**
	 * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.
	 * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.
	 * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).
	 *
	 * @default 500 ms.
	 */
	latency?: number;
	/**
	 * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.
	 *
	 * @default 50
	 */
	maxAge?: number;
	/**
	 * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).
	 * - `false` - will handle also circular references.
	 * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.
	 * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.
	 *   For each of them you can indicate if to include (by setting as `true`).
	 *   For `function` key you can also specify a custom function which handles serialization.
	 *   See [`jsan`](https://github.com/kolodny/jsan) for more details.
	 */
	serialize?: boolean | {
		date?: boolean;
		regex?: boolean;
		undefined?: boolean;
		error?: boolean;
		symbol?: boolean;
		map?: boolean;
		set?: boolean;
		function?: boolean | Function;
	};
	/**
	 * function which takes `action` object and id number as arguments, and should return `action` object back.
	 */
	actionSanitizer?: <A extends Action>(action: A, id: number) => A;
	/**
	 * function which takes `state` object and index as arguments, and should return `state` object back.
	 */
	stateSanitizer?: <S>(state: S, index: number) => S;
	/**
	 * *array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).
	 * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.
	 */
	actionsBlacklist?: string[];
	/**
	 * *array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).
	 * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.
	 */
	actionsWhitelist?: string[];
	/**
	 * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.
	 * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.
	 */
	predicate?: <S, A extends Action>(state: S, action: A) => boolean;
	/**
	 * if specified as `false`, it will not record the changes till clicking on `Start recording` button.
	 * Available only for Redux enhancer, for others use `autoPause`.
	 *
	 * @default true
	 */
	shouldRecordChanges?: boolean;
	/**
	 * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.
	 * If not specified, will commit when paused. Available only for Redux enhancer.
	 *
	 * @default "@@PAUSED""
	 */
	pauseActionType?: string;
	/**
	 * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.
	 * Not available for Redux enhancer (as it already does it but storing the data to be sent).
	 *
	 * @default false
	 */
	autoPause?: boolean;
	/**
	 * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.
	 * Available only for Redux enhancer.
	 *
	 * @default false
	 */
	shouldStartLocked?: boolean;
	/**
	 * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.
	 *
	 * @default true
	 */
	shouldHotReload?: boolean;
	/**
	 * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.
	 *
	 * @default false
	 */
	shouldCatchErrors?: boolean;
	/**
	 * If you want to restrict the extension, specify the features you allow.
	 * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.
	 * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.
	 * Otherwise, you'll get/set the data right from the monitor part.
	 */
	features?: {
		/**
		 * start/pause recording of dispatched actions
		 */
		pause?: boolean;
		/**
		 * lock/unlock dispatching actions and side effects
		 */
		lock?: boolean;
		/**
		 * persist states on page reloading
		 */
		persist?: boolean;
		/**
		 * export history of actions in a file
		 */
		export?: boolean | "custom";
		/**
		 * import history of actions from a file
		 */
		import?: boolean | "custom";
		/**
		 * jump back and forth (time travelling)
		 */
		jump?: boolean;
		/**
		 * skip (cancel) actions
		 */
		skip?: boolean;
		/**
		 * drag and drop actions in the history list
		 */
		reorder?: boolean;
		/**
		 * dispatch custom actions or action creators
		 */
		dispatch?: boolean;
		/**
		 * generate tests for the selected actions
		 */
		test?: boolean;
	};
}
export declare type Reducer<T, P extends any[] = any[]> = (state: T, ...params: P) => T | false | Promise<T | false>;
export declare enum PerformanceMeasurement {
	StartEnd = "startEnd",
	All = "all"
}
export interface StoreOptions {
	history?: Partial<HistoryOptions>;
	logDispatchedActions?: boolean;
	measurePerformance?: PerformanceMeasurement;
	propagateError?: boolean;
	logDefinitions?: LogDefinitions;
	devToolsOptions?: DevToolsOptions;
}
export interface PipedDispatch<T> {
	pipe: <P extends any[]>(reducer: Reducer<T, P> | string, ...params: P) => PipedDispatch<T>;
	dispatch: () => Promise<void>;
}
export declare class UnregisteredActionError<T, P extends any[]> extends Error {
	constructor(reducer?: string | Reducer<T, P>);
}
export declare class Store<T> {
	private initialState;
	readonly state: Observable<T>;
	private logger;
	private devToolsAvailable;
	private devTools;
	private actions;
	private middlewares;
	private _state;
	private options;
	private _markNames;
	private _measureNames;
	private dispatchQueue;
	constructor(initialState: T, options?: Partial<StoreOptions>);
	registerMiddleware<S extends undefined>(reducer: Middleware<T, undefined>, placement: MiddlewarePlacement): void;
	registerMiddleware<S extends NonNullable<any>>(reducer: Middleware<T, S>, placement: MiddlewarePlacement, settings: S): void;
	unregisterMiddleware(reducer: Middleware<T, any>): void;
	isMiddlewareRegistered(middleware: Middleware<T, any>): boolean;
	registerAction(name: string, reducer: Reducer<T>): void;
	unregisterAction(reducer: Reducer<T>): void;
	isActionRegistered(reducer: Reducer<T> | string): boolean;
	resetToState(state: T): void;
	dispatch<P extends any[]>(reducer: Reducer<T, P> | string, ...params: P): Promise<void>;
	pipe<P extends any[]>(reducer: Reducer<T, P> | string, ...params: P): PipedDispatch<T>;
	private lookupAction;
	private queueDispatch;
	private handleQueue;
	private internalDispatch;
	private executeMiddlewares;
	private setupDevTools;
	private updateDevToolsState;
	private registerHistoryMethods;
	private mark;
	private clearMarks;
	private measure;
	private clearMeasures;
}
export declare function dispatchify<T, P extends any[]>(action: Reducer<T, P> | string): (...params: P) => Promise<void>;
export declare type StepFn<T> = (res: T) => void;
export declare function executeSteps<T>(store: Store<T>, shouldLogResults: boolean, ...steps: StepFn<T>[]): Promise<void>;
export interface ConnectToSettings<T, R = T | any> {
	onChanged?: string;
	selector: ((store: Store<T>) => Observable<R>) | MultipleSelector<T, R>;
	setup?: string;
	target?: string;
	teardown?: string;
}
export interface MultipleSelector<T, R = T | any> {
	[key: string]: ((store: Store<T>) => Observable<R>);
}
export declare function connectTo<T, R = any>(settings?: ((store: Store<T>) => Observable<R>) | ConnectToSettings<T, R>): (target: any) => void;
export interface FrameworkConfiguration {
	container: Container;
}
export interface StorePluginOptions<T> extends StoreOptions {
	initialState: T;
}
export declare function configure<T>(aurelia: FrameworkConfiguration, options: Partial<StorePluginOptions<T>>): void;

export {};
